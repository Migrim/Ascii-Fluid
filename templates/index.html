<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Terminal Blocks</title>
    <style>
      html,
      body {
        overflow: hidden;
        margin: 0;
        padding: 0;
      }
      body {
        background-color: black;
        color: white;
        text-align: center;
        position: relative;
      }
      #game {
        width: 90%;
        max-width: 800px;
        height: 600px;
        margin: 20px auto;
        font-family: monospace;
        white-space: pre;
        font-size: 20px;
        line-height: 20px;
        background-color: black;
        overflow: hidden;
        border: none;
      }
      #nextPiece {
        position: absolute;
        top: 20px;
        right: 20px;
        background-color: black;
        color: white;
        font-family: monospace;
        white-space: pre;
        font-size: 20px;
        line-height: 20px;
        border: 2px solid white;
        padding: 10px;
      }
      #pauseModal,
      #exitModal {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0,0,0,0.9);
        border: 2px solid white;
        padding: 20px;
        font-family: monospace;
        white-space: pre;
        font-size: 24px;
        color: white;
        display: none;
        z-index: 10;
      }
      #toast {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px 20px;
        border-radius: 5px;
        font-family: monospace;
        font-size: 16px;
        display: none;
        z-index: 9999;
      }
      #coinDisplay {
        display: inline-block;
        width: 80px;
        height: 40px;
        vertical-align: middle;
      }
      .coin {
        display: block;
        font-family: monospace;
        font-size: 24px;
        transform-style: preserve-3d;
        animation: rotateCoin 2s linear infinite;
      }
      @keyframes rotateCoin {
        from { transform: rotateY(0deg); }
        to { transform: rotateY(360deg); }
      }
      .theme-preview {
        display: inline-block;
        border: 1px solid white;
        padding: 10px;
        max-width: 200px;
        word-wrap: break-word;
      }
    </style>
  </head>
  <body>
    <div id="game"></div>
    <div id="nextPiece"></div>
    <div id="pauseModal">PAUSED<br><br>Press P to resume</div>
    <div id="exitModal">Exit Game?<br><br>Press Y to confirm, N to resume</div>
    <div id="toast"></div>
    <script>
      let gameState = "menu";
      const mainMenuOptions = ["Play", "Instructions", "Settings", "Customization"];
      let currentMainMenuIndex = 0;
      const settingsMenuOptions = [
        "Difficulty: Normal",
        "Color Mode: Colors",
        "Ghost Piece: On",
        "Sound: On",
        "Volume: 100%",
        "Back"
      ];
      let currentSettingsMenuIndex = 0;
      const gameModes = ["Normal", "Time Attack", "Chaos Blitz", "Hardcore"];
      let currentGameModeIndex = 0;
      let selectedGameMode = "Normal";
      const boardWidth = 10;
      const boardHeight = 20;
      let board = [];
      let fallingPiece = null;
      let gameOver = false;
      let animating = false;
      let animatingRows = [];
      let flashState = false;
      let flashInterval = null;
      let level = 0;
      let linesCleared = 0;
      let score = 0;
      let paused = false;
      let pauseStartTime = null;
      let combo = 0;
      let specialMessage = "";
      let difficultySetting = "Normal";
      let colorMode = "colors";
      let ghostPieceSetting = "On";
      let soundSetting = "On";
      let soundVolume = 1;
      const difficultyConfig = {
        Easy: { initialSpeed: 700, acceleration: 0.98 },
        Normal: { initialSpeed: 500, acceleration: 0.95 },
        Hard: { initialSpeed: 300, acceleration: 0.90 }
      };
      let coins = 0;
      let currentBlockAppearance = "[]";
      let currentBorderStyle = { topLeft: "┌", topRight: "┐", bottomLeft: "└", bottomRight: "┘", horizontal: "─", vertical: "│" };
      let currentTheme = { background: "black", color: "white" };
      const storeItems = {
        block: [
          { name: "Standard", appearance: "[]", price: 0, unlocked: true },
          { name: "Neon", appearance: "||", price: 0, unlocked: true },
          { name: "Dotted", appearance: "░░", price: 0, unlocked: true },
          { name: "Block", appearance: "██", price: 0, unlocked: true },
          { name: "Hashes", appearance: "##", price: 100, unlocked: false },
          { name: "Arrows", appearance: "<>", price: 100, unlocked: false },
          { name: "UwU", appearance: ":3", price: 3, unlocked: false },
          { name: "Circle", appearance: "◯", price: 200, unlocked: false },
          { name: "Wave", appearance: "▒▒", price: 200, unlocked: false },
          { name: "Diamond", appearance: "♦♦", price: 300, unlocked: false },
          { name: "Sliced", appearance: "▓▓", price: 100, unlocked: false },
          { name: "Gradient", appearance: "▭", price: 200, unlocked: false },
          { name: "Pixel", appearance: "■■", price: 500, unlocked: false }
        ],
        border: [
          { name: "Standard", topLeft: "┌", topRight: "┐", bottomLeft: "└", bottomRight: "┘", horizontal: "─", vertical: "│", price: 0, unlocked: true },
          { name: "Double", topLeft: "╔", topRight: "╗", bottomLeft: "╚", bottomRight: "╝", horizontal: "═", vertical: "║", price: 0, unlocked: true },
          { name: "Dashed", topLeft: "┌", topRight: "┐", bottomLeft: "└", bottomRight: "┘", horizontal: "┄", vertical: "┆", price: 0, unlocked: true },
          { name: "Sharp", topLeft: "┏", topRight: "┓", bottomLeft: "┗", bottomRight: "┛", horizontal: "━", vertical: "┃", price: 200, unlocked: false },
          { name: "Star", topLeft: "✶", topRight: "✶", bottomLeft: "✶", bottomRight: "✶", horizontal: "*", vertical: "*", price: 200, unlocked: false },
          { name: "Rounded", topLeft: "╭", topRight: "╮", bottomLeft: "╰", bottomRight: "╯", horizontal: "─", vertical: "│", price: 200, unlocked: false },
          { name: "Double Dashed", topLeft: "┏", topRight: "┓", bottomLeft: "┗", bottomRight: "┛", horizontal: "┅", vertical: "┆", price: 500, unlocked: false },
          { name: "Fancy", topLeft: "❰", topRight: "❱", bottomLeft: "❰", bottomRight: "❱", horizontal: "═", vertical: "║", price: 10, unlocked: false }
        ],
        theme: [
          { name: "Default", background: "black", color: "white", price: 0, unlocked: true },
          { name: "Cozy", background: "black", color: "#f599ff", price: 0, unlocked: true },
          { name: "Sky Blue", background: "black", color: "#71bbf8", price: 0, unlocked: true },
          { name: "Red", background: "black", color: "#ff1717", price: 200, unlocked: false },
          { name: "Green Matrix", background: "black", color: "lime", price: 200, unlocked: false },
          { name: "Blue Ocean", background: "black", color: "#006efe", price: 200, unlocked: false },
          { name: "Yellow", background: "black", color: "#fee443", price: 0, unlocked: true }
        ],
        tetromino: [
          { name: "Default", colors: { I: "cyan", J: "blue", L: "orange", O: "yellow", S: "lime", T: "magenta", Z: "red" }, price: 0, unlocked: true },
          { name: "Gay Pride", colors: { I: "red", J: "orange", L: "yellow", O: "green", S: "blue", T: "indigo", Z: "violet" }, price: 0, unlocked: true },
          { name: "Trans Pride", colors: { I: "lightblue", J: "pink", L: "white", O: "white", S: "pink", T: "lightblue", Z: "lightblue" }, price: 0, unlocked: true },
          { name: "Neon", colors: { I: "#39FF14", J: "#FF073A", L: "#00FFFF", O: "#FF00FF", S: "#FFFF00", T: "#FF4500", Z: "#00FF7F" }, price: 500, unlocked: false },
          { name: "Pastel", colors: { I: "lightblue", J: "lightgreen", L: "lightyellow", O: "lightpink", S: "lavender", T: "peachpuff", Z: "lightcoral" }, price: 500, unlocked: false },
          { name: "Vivid", colors: { I: "#00FFFF", J: "#0000FF", L: "#FFA500", O: "#FFFF00", S: "#00FF00", T: "#FF00FF", Z: "#FF0000" }, price: 500, unlocked: false }
        ]
      };
      const storeCategories = ["block", "border", "theme", "tetromino"];
      let currentStoreCategory = "block";
      let currentStoreItemIndex = 0;
      const tetrominoes = [
        { name: "I", shape: [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 2, y: 0 }, { x: 3, y: 0 }] },
        { name: "J", shape: [{ x: 0, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1 }] },
        { name: "L", shape: [{ x: 2, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1 }] },
        { name: "O", shape: [{ x: 1, y: 0 }, { x: 2, y: 0 }, { x: 1, y: 1 }, { x: 2, y: 1 }] },
        { name: "S", shape: [{ x: 1, y: 0 }, { x: 2, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }] },
        { name: "T", shape: [{ x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1 }] },
        { name: "Z", shape: [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 1, y: 1 }, { x: 2, y: 1 }] }
      ];
      let tetrominoColors = { I: "cyan", J: "blue", L: "orange", O: "yellow", S: "lime", T: "magenta", Z: "red" };
      let highScore = 0;
      const SPACEBAR_HOLD_THRESHOLD = 200;
      const SPACEBAR_DROP_INTERVAL_TIME = 100;
      let spacebarHeld = false;
      let spacebarHoldTimeout = null;
      let spacebarDropInterval = null;
      let spacebarKeyDownTime = 0;
      function playSound(type) {
        if (soundSetting !== "On") return;
        if (!window.audioCtx) window.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = window.audioCtx.createOscillator();
        const gainNode = window.audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(window.audioCtx.destination);
        oscillator.type = "square";
        let frequency = 440, duration = 0.1;
        if (type === "rotate") { frequency = 523.25; duration = 0.08; }
        else if (type === "move") { frequency = 392; duration = 0.05; }
        else if (type === "drop") { frequency = 329.63; duration = 0.1; }
        else if (type === "menuNavigate") { frequency = 740; duration = 0.05; }
        else if (type === "menuSelect") { frequency = 880; duration = 0.1; }
        else if (type === "menuCancel") { frequency = 330; duration = 0.1; }
        else if (type === "menuChange") { frequency = 600; duration = 0.07; }
        oscillator.frequency.setValueAtTime(frequency, window.audioCtx.currentTime);
        oscillator.start();
        gainNode.gain.setValueAtTime(soundVolume, window.audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.001, window.audioCtx.currentTime + duration);
        oscillator.stop(window.audioCtx.currentTime + duration);
      }
      function playMelody(melody) {
        if (soundSetting !== "On") return;
        if (!window.audioCtx) window.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let t = window.audioCtx.currentTime;
        melody.forEach(note => {
          const osc = window.audioCtx.createOscillator();
          const gain = window.audioCtx.createGain();
          osc.connect(gain);
          gain.connect(window.audioCtx.destination);
          osc.type = "square";
          osc.frequency.setValueAtTime(note.frequency, t);
          osc.start(t);
          gain.gain.setValueAtTime(soundVolume, t);
          gain.gain.exponentialRampToValueAtTime(0.001, t + note.duration);
          osc.stop(t + note.duration);
          t += note.duration * 1.1;
        });
      }
      const levelUpMelody = [
        { frequency: 523.25, duration: 0.2 },
        { frequency: 587.33, duration: 0.2 },
        { frequency: 659.25, duration: 0.2 }
      ];
      const gameOverMelody = [
        { frequency: 392, duration: 0.3 },
        { frequency: 349.23, duration: 0.3 },
        { frequency: 329.63, duration: 0.3 },
        { frequency: 293.66, duration: 0.3 }
      ];
      const lineClearMelody = [
        { frequency: 523.25, duration: 0.1 },
        { frequency: 659.25, duration: 0.1 }
      ];
      const maxLineMelody = [
        { frequency: 880, duration: 0.2 },
        { frequency: 987.77, duration: 0.2 },
        { frequency: 1046.5, duration: 0.2 }
      ];
      function loadGameData(){
        let data = localStorage.getItem("terminalBlocksData");
        if(data){
          let obj = JSON.parse(data);
          highScore = obj.highScore !== undefined ? obj.highScore : 0;
          difficultySetting = obj.difficultySetting || difficultySetting;
          colorMode = obj.colorMode || colorMode;
          coins = obj.coins !== undefined ? obj.coins : coins;
          currentBlockAppearance = obj.currentBlockAppearance || currentBlockAppearance;
          currentBorderStyle = obj.currentBorderStyle || currentBorderStyle;
          currentTheme = obj.currentTheme || currentTheme;
          tetrominoColors = obj.currentTetrominoScheme || tetrominoColors;
          ghostPieceSetting = obj.ghostPieceSetting || ghostPieceSetting;
          soundSetting = obj.soundSetting || soundSetting;
          if(obj.soundVolume !== undefined) soundVolume = obj.soundVolume;
          document.body.style.backgroundColor = currentTheme.background;
          document.body.style.color = currentTheme.color;
        }
      }
      function saveGameData(){ 
        let data = { 
          highScore: highScore, 
          difficultySetting: difficultySetting, 
          colorMode: colorMode, 
          coins: coins, 
          currentBlockAppearance: currentBlockAppearance, 
          currentBorderStyle: currentBorderStyle, 
          currentTheme: currentTheme,
          currentTetrominoScheme: tetrominoColors,
          ghostPieceSetting: ghostPieceSetting,
          soundSetting: soundSetting,
          soundVolume: soundVolume,
          storeItems: storeItems 
        }; 
        localStorage.setItem("terminalBlocksData", JSON.stringify(data)); 
      }
      function rotateOffset(offset, rotation) {
        let x = offset.x, y = offset.y;
        for (let i = 0; i < rotation; i++) {
          let temp = x;
          x = -y;
          y = temp;
        }
        return { x, y };
      }
      function getPieceCells(piece) {
        return piece.shape.map(cell => {
          let r = rotateOffset(cell, piece.rotation);
          return { x: piece.x + r.x, y: piece.y + r.y };
        });
      }
      function validMove(newX, newY, newRotation) {
        for (let cell of fallingPiece.shape) {
          let r = rotateOffset(cell, newRotation);
          let x = newX + r.x;
          let y = newY + r.y;
          if (x < 0 || x >= boardWidth || y >= boardHeight) {
            if (y >= 0) return false;
          }
          if (y >= 0 && board[y][x] !== 0) return false;
        }
        return true;
      }
      function lockPiece(piece) {
        let cells = getPieceCells(piece);
        for (let cell of cells) {
          if (cell.y >= 0 && cell.y < boardHeight && cell.x >= 0 && cell.x < boardWidth) {
            board[cell.y][cell.x] = fallingPiece.name;
          }
        }
      }
      function getFullLines() {
        let fullLines = [];
        for (let y = 0; y < boardHeight; y++) {
          let full = true;
          for (let x = 0; x < boardWidth; x++) {
            if (board[y][x] === 0) {
              full = false;
              break;
            }
          }
          if (full) fullLines.push(y);
        }
        return fullLines;
      }
      function clearFullLines() {
        let newBoard = board.filter(row => row.some(cell => cell === 0));
        while (newBoard.length < boardHeight) {
          newBoard.unshift(new Array(boardWidth).fill(0));
        }
        board = newBoard;
      }
      function animateClearLines(callback) {
        animatingRows = getFullLines();
        let flashes = 0;
        flashInterval = setInterval(() => {
          flashState = !flashState;
          flashes++;
          renderGame();
          if (flashes >= 6) {
            clearInterval(flashInterval);
            animatingRows = [];
            callback();
          }
        }, 150);
      }
      function animateTetris(callback) {
        let flashes = 0;
        flashInterval = setInterval(() => {
          flashes++;
          specialMessage = flashes % 2 === 0 ? "Max Line!" : "";
          renderGame();
          if (flashes >= 6) {
            clearInterval(flashInterval);
            specialMessage = "";
            callback();
          }
        }, 150);
      }
      function animateLevelUp(callback) {
        playMelody(levelUpMelody);
        let flashes = 0;
        flashInterval = setInterval(() => {
          flashes++;
          specialMessage = flashes % 2 === 0 ? "LEVEL UP!" : "";
          renderGame();
          if (flashes >= 6) {
            clearInterval(flashInterval);
            specialMessage = "";
            callback();
          }
        }, 150);
      }
      function animateGameOver(callback) {
        playMelody(gameOverMelody);
        let flashes = 0;
        flashInterval = setInterval(() => {
          flashes++;
          specialMessage = (flashes % 2 === 0) ? "GAME OVER" : "";
          renderGame();
          if (flashes >= 8) {
            clearInterval(flashInterval);
            specialMessage = "";
            callback();
          }
        }, 200);
      }
      function computeGhostCells() {
        if (!fallingPiece || ghostPieceSetting === "Off") return [];
        let ghost = { x: fallingPiece.x, y: fallingPiece.y, shape: fallingPiece.shape, rotation: fallingPiece.rotation };
        while (validMove(ghost.x, ghost.y + 1, ghost.rotation)) {
          ghost.y++;
        }
        return getPieceCells(ghost);
      }
      let timeAttackRemaining = 60000;
      let lastTickTime = 0;
      let startTime = 0;
      function getDropSpeed() {
        let effectiveLevel = level + Math.floor((Date.now() - startTime) / 30000);
        if (selectedGameMode === "Hardcore") {
          return Math.max(50, Math.floor(100 * Math.pow(0.7, effectiveLevel)));
        } else {
          const config = difficultyConfig[difficultySetting];
          return Math.max(100, Math.floor(config.initialSpeed * Math.pow(config.acceleration, effectiveLevel)));
        }
      }
      function renderGame() {
        document.getElementById("nextPiece").style.display = "block";
        let header = "Level: " + level + "  Lines: " + linesCleared + "  Score: " + score;
        if (combo > 1) header += "  Combo: x" + combo;
        if (selectedGameMode === "Time Attack") {
          let timeLeftSec = Math.ceil(timeAttackRemaining / 1000);
          header += "  Time: " + timeLeftSec + "s";
        }
        header += "\n";
        const bs = currentBorderStyle;
        let topBorder = bs.topLeft + bs.horizontal.repeat(boardWidth * 2) + bs.topRight + "\n";
        let bottomBorder = bs.bottomLeft + bs.horizontal.repeat(boardWidth * 2) + bs.bottomRight + "\n";
        let output = header + topBorder;
        let fallingCells = getPieceCells(fallingPiece);
        let ghostCells = computeGhostCells();
        for (let y = 0; y < boardHeight; y++) {
          let row = bs.vertical;
          if (animatingRows.indexOf(y) !== -1) {
            let pattern = flashState ? "##" : "~~";
            row += pattern.repeat(boardWidth);
          } else {
            if (y === Math.floor(boardHeight / 2) && specialMessage) {
              let msg = specialMessage;
              let total = boardWidth * 2;
              let pad = Math.floor((total - msg.length) / 2);
              let spaces = " ".repeat(pad);
              row += spaces + msg + spaces;
              if (row.length < total + 1) row += " ";
            } else {
              for (let x = 0; x < boardWidth; x++) {
                let cellDraw = "  ";
                let inFalling = fallingCells.some(c => c.x === x && c.y === y);
                let inGhost = ghostCells.some(c => c.x === x && c.y === y);
                if (inFalling) {
                  cellDraw = colorMode === "colors" ? '<span style="color:' + tetrominoColors[fallingPiece.name] + ';">' + currentBlockAppearance + '</span>' : currentBlockAppearance;
                } else if (inGhost && board[y][x] === 0) {
                  cellDraw = colorMode === "colors" ? '<span style="color:gray;">..</span>' : "..";
                } else if (board[y][x] !== 0) {
                  cellDraw = colorMode === "colors" ? '<span style="color:' + tetrominoColors[board[y][x]] + ';">' + currentBlockAppearance + '</span>' : currentBlockAppearance;
                }
                row += cellDraw;
              }
            }
          }
          row += bs.vertical + "\n";
          output += row;
        }
        output += bottomBorder;
        document.getElementById("game").innerHTML = output;
        renderNextPiece();
      }
      function renderNextPiece() {
        if (!nextPiece) {
          document.getElementById("nextPiece").innerHTML = "";
          return;
        }
        let shape = nextPiece.shape;
        let minX = Math.min(...shape.map(c => c.x));
        let maxX = Math.max(...shape.map(c => c.x));
        let minY = Math.min(...shape.map(c => c.y));
        let maxY = Math.max(...shape.map(c => c.y));
        let width = maxX - minX + 1;
        let height = maxY - minY + 1;
        let grid = [];
        for (let y = 0; y < height; y++) {
          grid[y] = new Array(width).fill("  ");
        }
        for (let cell of shape) {
          let x = cell.x - minX;
          let y = cell.y - minY;
          grid[y][x] = colorMode === "colors" ? '<span style="color:' + tetrominoColors[nextPiece.name] + ';">' + currentBlockAppearance + '</span>' : currentBlockAppearance;
        }
        let output = "";
        for (let y = 0; y < height; y++) {
          let row = "";
          for (let x = 0; x < width; x++) {
            row += grid[y][x];
          }
          output += row + "<br>";
        }
        document.getElementById("nextPiece").innerHTML = output;
      }
      function renderMainMenu() {
        document.getElementById("nextPiece").style.display = "none";
        let logo = `
 ▄▄▄▄    ██▓     ▒█████   ▄████▄   ██ ▄█▀
▓█████▄ ▓██▒    ▒██▒  ██▒▒██▀ ▀█   ██▄█▒ 
▒██▒ ▄██▒██░    ▒██░  ██▒▒▓█    ▄ ▓███▄░ 
▒██░█▀  ▒██░    ▒██   ██░▒▓▓▄ ▄██▒▓██ █▄ 
░▓█  ▀█▓░██████▒░ ████▓▒░▒ ▓███▀ ░▒██▒ █▄
░▒▓███▀▒░ ▒░▓  ░░ ▒░▒░▒░ ░ ░▒ ▒  ░▒ ▒▒ ▓▒
▒░▒   ░ ░ ░ ▒  ░  ░ ▒ ▒░   ░  ▒   ░ ░▒ ▒░
 ░    ░   ░ ░   ░ ░░ ░  ░        ░ ░░ ░ 
 ░          ░  ░    ░ ░  ░ ░      ░  ░   `;
        let header = logo + "\n\nTerminal Blocks\n\nHigh Score: " + highScore + "\n\n";
        mainMenuOptions.forEach((option, i) => {
          header += (i === currentMainMenuIndex ? "> " : "  ") + option + "\n";
        });
        header += "\nUse W/S to navigate and Enter to select.";
        document.getElementById("game").innerHTML = header;
      }
      function renderModeSelect() {
        document.getElementById("nextPiece").style.display = "none";
        let output = "Select Game Mode\n\n";
        let maxLen = Math.max(...gameModes.map(mode => mode.length));
        let boxWidth = maxLen + 2;
        gameModes.forEach((mode, i) => {
          let top = "┌" + "─".repeat(boxWidth) + "┐";
          let middle = "│" + mode.padEnd(boxWidth, " ") + "│";
          let bottom = "└" + "─".repeat(boxWidth) + "┘";
          let marker = i === currentGameModeIndex ? ">" : " ";
          output += marker + " " + top + "\n" + marker + " " + middle + "\n" + marker + " " + bottom + "\n\n";
        });
        output += "Use W/S to navigate and Enter to select.\nPress Esc/Q to return to Main Menu.";
        document.getElementById("game").innerHTML = output;
      }
      function renderSettingsMenu() {
        document.getElementById("nextPiece").style.display = "none";
        let options = [
          "Difficulty: " + difficultySetting,
          "Color Mode: " + (colorMode === "colors" ? "Colors" : "Monochrome"),
          "Ghost Piece: " + ghostPieceSetting,
          "Sound: " + soundSetting,
          "Volume: " + Math.round(soundVolume * 100) + "%",
          "Back"
        ];
        let width = 34;
        let topBorder = "╭" + "─".repeat(width - 2) + "╮\n";
        let title = " SETTINGS ";
        let titlePadding = Math.floor((width - 2 - title.length) / 2);
        let titleLine = "│" + " ".repeat(titlePadding) + title + " ".repeat(width - 2 - titlePadding - title.length) + "│\n";
        let separator = "├" + "─".repeat(width - 2) + "┤\n";
        let optionLines = "";
        for (let i = 0; i < options.length; i++) {
          let line = options[i];
          line = i === currentSettingsMenuIndex ? "> " + line : "  " + line;
          optionLines += "│" + line.padEnd(width - 2, " ") + "│\n";
        }
        let bottomBorder = "╰" + "─".repeat(width - 2) + "╯\n";
        let instructions = "\nUse W/S to navigate, A/D to change, Enter to select, Esc/Q to return.";
        let output = topBorder + titleLine + separator + optionLines + bottomBorder + instructions;
        document.getElementById("game").innerHTML = output;
      }
      function renderStore() {
        let content = "<div id='storeContent'>";
        content += "<div style='font-size:24px; font-weight:bold; margin-bottom:10px;'>Customisation Store</div>";
        content += "<div id='coinDisplay' style='margin-bottom:10px;'>Coins: " + coins + "</div>";
        const catNames = { block: "Block", border: "Border", theme: "Theme", tetromino: "Tetromino" };
        let currentCatIndex = storeCategories.indexOf(currentStoreCategory);
        content += "<div id='storeCategories' style='margin-bottom:20px;'>Categories: ";
        storeCategories.forEach((cat, i) => {
          content += i === currentCatIndex ? "<strong>[" + catNames[cat] + "]</strong> " : catNames[cat] + " ";
        });
        content += "</div>";
        let items = storeItems[currentStoreCategory];
        let currentItem = items[currentStoreItemIndex];
        let prevIndex = (currentStoreItemIndex - 1 + items.length) % items.length;
        let nextIndex = (currentStoreItemIndex + 1) % items.length;
        content += "<div id='storeItem'>";
        content += "<div style='margin-bottom:10px; font-size:18px;'>Prev: " + items[prevIndex].name + " | Current: <span style='color:yellow;'>" + currentItem.name + "</span> | Next: " + items[nextIndex].name + "</div>";
        if (currentStoreCategory === "block") {
          let preview = currentItem.appearance + currentItem.appearance + "<br>" + currentItem.appearance + currentItem.appearance;
          content += "<div style='margin:20px;'>" + preview + "</div>";
        } else if (currentStoreCategory === "border") {
          let tl = currentItem.topLeft || currentItem.corner;
          let tr = currentItem.topRight || currentItem.corner;
          let bl = currentItem.bottomLeft || currentItem.corner;
          let br = currentItem.bottomRight || currentItem.corner;
          let hor = currentItem.horizontal;
          let ver = currentItem.vertical;
          let sampleWidth = 6;
          let sampleLine = hor.repeat(sampleWidth);
          let sampleBox = tl + sampleLine + tr + "<br>" + ver + " ".repeat(sampleWidth) + ver + "<br>" + bl + sampleLine + br;
          content += "<div style='margin:20px;'>" + sampleBox + "</div>";
        } else if (currentStoreCategory === "theme") {
          content += "<div style='margin:20px;'><div class='theme-preview' style='background:" + currentItem.background + "; color:" + currentItem.color + ";'>Sample</div></div>";
        } else if (currentStoreCategory === "tetromino") {
          let scheme = currentItem.colors;
          let preview = "";
          ["I","J","L","O","S","T","Z"].forEach(type => {
            preview += colorMode === "colors" ? '<span style="color:' + scheme[type] + ';">' + currentBlockAppearance + '</span> ' : currentBlockAppearance + " ";
          });
          content += "<div style='margin:20px;'>" + preview + "</div>";
        }
        content += "<div style='margin-top:20px;'>Price: " + currentItem.price + " | Status: " + (currentItem.unlocked ? "Owned" : "Not Owned") + "</div>";
        content += "<div style='margin-top:20px;'>Use Up/Down to switch category, Left/Right to change item.<br>Press Enter to purchase/select, or Esc/Q to return.</div>";
        content += "</div></div>";
        document.getElementById("game").innerHTML = content;
      }
      function renderHelpMenu() {
        document.getElementById("nextPiece").style.display = "none";
        let output = "Instructions\n\n";
        output += "Movement: Use W/A/S/D or Arrow keys to move pieces.\n";
        output += "Rotation: Press W or Up to rotate, Z to counter-rotate.\n";
        output += "Drop: Press Spacebar for instant drop (tap) or hold for a slower continuous drop.\n";
        output += "Pause: Press P to pause.\n";
        output += "Exit: Press Esc/Q to open the exit modal.\n";
        output += "Menu Navigation: Use W/S to navigate and Enter to select.\n";
        output += "\nPress Esc/Q to return to the Main Menu.";
        document.getElementById("game").innerHTML = output;
      }
      function renderGameOver() {
        document.getElementById("nextPiece").style.display = "none";
        let art = `
  ▄████  ▄▄▄       ███▄ ▄███▓▓█████    
 ██▒ ▀█▒▒████▄    ▓██▒▀█▀ ██▒▓█   ▀    
▒██░▄▄▄░▒██  ▀█▄  ▓██    ▓██░▒███      
░▓█  ██▓░██▄▄▄▄██ ▒██    ▒██ ▒▓█  ▄    
░▒▓███▀▒ ▓█   ▓██▒▒██▒   ░██▒░▒████▒   
 ░▒   ▒  ▒▒   ▓▒█░░ ▒░   ░  ░░░ ▒░ ░   
  ░   ░   ▒   ▒▒ ░░  ░      ░ ░ ░  ░   
░ ░   ░   ░   ▒   ░      ░      ░      
      ░       ░  ░       ░      ░  ░   
                                       
 ▒█████   ██▒   █▓▓█████  ██▀███       
▒██▒  ██▒▓██░   █▒▓█   ▀ ▓██ ▒ ██▒     
▒██░  ██▒ ▓██  █▒░▒███   ▓██ ░▄█ ▒     
▒██   ██░  ▒██ █░░▒▓█  ▄ ▒██▀▀█▄       
░ ████▓▒░   ▒▀█░  ░▒████▒░██▓ ▒██▒     
░ ▒░▒░▒░    ░ ▐░  ░░ ▒░ ░░ ▒▓ ░▒▓░     
  ░ ▒ ▒░    ░ ░░   ░ ░  ░  ░▒ ░ ▒░     
░ ░ ░ ▒       ░░     ░     ░░   ░      
    ░ ░        ░     ░  ░   ░          
              ░                          `;
        let output = art + "\n";
        output += "Score: " + score + "\n";
        output += "Coins Earned: " + Math.floor(score / 25) + "\n";
        output += "\nPress Enter to return to the Main Menu.";
        document.getElementById("game").innerHTML = output;
      }
      function tryRotate(newRotation) {
        if (fallingPiece.name === "O") return true;
        if (validMove(fallingPiece.x, fallingPiece.y, newRotation)) {
          fallingPiece.rotation = newRotation;
          return true;
        }
        if (validMove(fallingPiece.x - 1, fallingPiece.y, newRotation)) {
          fallingPiece.x--;
          fallingPiece.rotation = newRotation;
          return true;
        }
        if (validMove(fallingPiece.x + 1, fallingPiece.y, newRotation)) {
          fallingPiece.x++;
          fallingPiece.rotation = newRotation;
          return true;
        }
        return false;
      }
      let nextPiece;
      function spawnPiece() {
        const index = Math.floor(Math.random() * tetrominoes.length);
        const tetromino = tetrominoes[index];
        return { x: Math.floor(boardWidth / 2) - 2, y: 0, shape: tetromino.shape, rotation: 0, name: tetromino.name };
      }
      function initBoard() {
        board = [];
        for (let y = 0; y < boardHeight; y++) {
          let row = [];
          for (let x = 0; x < boardWidth; x++) {
            row.push(0);
          }
          board.push(row);
        }
      }
      function gameTick() {
        if (gameOver || animating || paused) return;
        if (selectedGameMode === "Chaos Blitz" && Math.random() < 0.05) {
          let oldShape = fallingPiece.shape;
          let oldName = fallingPiece.name;
          let newTetromino = tetrominoes[Math.floor(Math.random() * tetrominoes.length)];
          fallingPiece.shape = newTetromino.shape;
          fallingPiece.name = newTetromino.name;
          if (!validMove(fallingPiece.x, fallingPiece.y, fallingPiece.rotation)) {
            fallingPiece.shape = oldShape;
            fallingPiece.name = oldName;
          } else {
            specialMessage = "CHAOS!";
            setTimeout(() => { specialMessage = ""; renderGame(); }, 500);
          }
        }
        if (selectedGameMode === "Time Attack") {
          let now = Date.now();
          let dt = now - lastTickTime;
          timeAttackRemaining -= dt;
          lastTickTime = now;
          if (timeAttackRemaining <= 0) gameOver = true;
        }
        if (validMove(fallingPiece.x, fallingPiece.y + 1, fallingPiece.rotation)) {
          fallingPiece.y++;
          renderGame();
        } else {
          lockPiece(fallingPiece);
          let fullLines = getFullLines();
          if (fullLines.length > 0) {
            if (selectedGameMode === "Time Attack") {
              let bonus = 0;
              if (fullLines.length === 1) bonus = 2000;
              else if (fullLines.length === 2) bonus = 3000;
              else if (fullLines.length === 3) bonus = 4000;
              else if (fullLines.length === 4) bonus = 6000;
              timeAttackRemaining += bonus;
            }
            combo++;
            if (fullLines.length === 4) {
              playMelody(maxLineMelody);
              animating = true;
              animateTetris(() => {
                clearFullLines();
                linesCleared += fullLines.length;
                let basePoints = 1200 * (level + 1);
                let pointsAwarded = basePoints * (combo > 1 ? combo : 1);
                score += pointsAwarded;
                let newLevel = Math.floor(linesCleared / 10);
                if (newLevel > level) {
                  animateLevelUp(() => {
                    level = newLevel;
                    animating = false;
                    fallingPiece = nextPiece;
                    nextPiece = spawnPiece();
                    if (!validMove(fallingPiece.x, fallingPiece.y, fallingPiece.rotation)) gameOver = true;
                    renderGame();
                  });
                } else {
                  level = newLevel;
                  animating = false;
                  fallingPiece = nextPiece;
                  nextPiece = spawnPiece();
                  if (!validMove(fallingPiece.x, fallingPiece.y, fallingPiece.rotation)) gameOver = true;
                  renderGame();
                }
              });
            } else {
              playMelody(lineClearMelody);
              animating = true;
              animateClearLines(() => {
                clearFullLines();
                linesCleared += fullLines.length;
                let basePoints = fullLines.length === 1 ? 40 * (level + 1) : fullLines.length === 2 ? 100 * (level + 1) : 300 * (level + 1);
                let pointsAwarded = basePoints * (combo > 1 ? combo : 1);
                score += pointsAwarded;
                let newLevel = Math.floor(linesCleared / 10);
                if (newLevel > level) {
                  animateLevelUp(() => {
                    level = newLevel;
                    animating = false;
                    fallingPiece = nextPiece;
                    nextPiece = spawnPiece();
                    if (!validMove(fallingPiece.x, fallingPiece.y, fallingPiece.rotation)) gameOver = true;
                    renderGame();
                  });
                } else {
                  level = newLevel;
                  animating = false;
                  fallingPiece = nextPiece;
                  nextPiece = spawnPiece();
                  if (!validMove(fallingPiece.x, fallingPiece.y, fallingPiece.rotation)) gameOver = true;
                  renderGame();
                }
              });
            }
          } else {
            combo = 0;
            fallingPiece = nextPiece;
            nextPiece = spawnPiece();
            if (!validMove(fallingPiece.x, fallingPiece.y, fallingPiece.rotation)) gameOver = true;
          }
          renderGame();
        }
      }
      function gameLoop() {
        if (gameState !== "game") return;
        if (paused) {
          setTimeout(gameLoop, 100);
          return;
        }
        gameTick();
        if (!gameOver) {
          setTimeout(gameLoop, getDropSpeed());
        } else {
          coins += Math.floor(score / 25);
          if (score > highScore) highScore = score;
          saveGameData();
          gameState = "gameover";
          playMelody(gameOverMelody);
          animateGameOver(renderGameOver);
        }
      }
      function startGame() {
        gameState = "game";
        gameOver = false;
        level = 0;
        linesCleared = 0;
        score = 0;
        combo = 0;
        paused = false;
        updatePauseModal();
        initBoard();
        startTime = Date.now();
        if (selectedGameMode === "Time Attack") {
          timeAttackRemaining = 60000;
          lastTickTime = Date.now();
        }
        nextPiece = spawnPiece();
        fallingPiece = nextPiece;
        nextPiece = spawnPiece();
        renderNextPiece();
        gameLoop();
      }
      function updatePauseModal() {
        let modal = document.getElementById("pauseModal");
        modal.style.display = paused ? "block" : "none";
        if (paused) {
          document.getElementById("exitModal").style.display = "none";
        }
      }
      function updateExitModal(show) {
        let modal = document.getElementById("exitModal");
        modal.style.display = show ? "block" : "none";
        if (show) {
          document.getElementById("pauseModal").style.display = "none";
        }
      }
      function showToast(msg) {
        let toast = document.getElementById("toast");
        toast.innerHTML = msg;
        toast.style.display = "block";
        setTimeout(() => {
          toast.style.display = "none";
        }, 3000);
      }
      document.addEventListener("keydown", function (e) {
        if (gameState === "game" && document.getElementById("exitModal").style.display === "block") {
          if (e.key.toLowerCase() === "y") {
            paused = false;
            updateExitModal(false);
            gameState = "menu";
            playSound("menuSelect");
            renderMainMenu();
          } else if (e.key.toLowerCase() === "n") {
            paused = false;
            updateExitModal(false);
            playSound("menuCancel");
            renderGame();
          }
          return;
        }
        if (gameState === "menu") {
          if (e.key === "ArrowUp" || e.key.toLowerCase() === "w") {
            currentMainMenuIndex = (currentMainMenuIndex - 1 + mainMenuOptions.length) % mainMenuOptions.length;
            playSound("menuNavigate");
            renderMainMenu();
          } else if (e.key === "ArrowDown" || e.key.toLowerCase() === "s") {
            currentMainMenuIndex = (currentMainMenuIndex + 1) % mainMenuOptions.length;
            playSound("menuNavigate");
            renderMainMenu();
          } else if (e.key === "Enter") {
            playSound("menuSelect");
            const option = mainMenuOptions[currentMainMenuIndex];
            if (option === "Play") {
              gameState = "modeSelect";
              currentGameModeIndex = gameModes.indexOf(selectedGameMode);
              renderModeSelect();
            } else if (option === "Instructions") {
              gameState = "help";
              renderHelpMenu();
            } else if (option === "Settings") {
              gameState = "settings";
              currentSettingsMenuIndex = 0;
              renderSettingsMenu();
            } else if (option === "Customization") {
              gameState = "customization";
              currentStoreCategory = "block";
              currentStoreItemIndex = 0;
              renderStore();
            }
          }
          return;
        } else if (gameState === "modeSelect") {
          if (e.key === "ArrowUp" || e.key.toLowerCase() === "w") {
            currentGameModeIndex = (currentGameModeIndex - 1 + gameModes.length) % gameModes.length;
            playSound("menuNavigate");
            renderModeSelect();
          } else if (e.key === "ArrowDown" || e.key.toLowerCase() === "s") {
            currentGameModeIndex = (currentGameModeIndex + 1) % gameModes.length;
            playSound("menuNavigate");
            renderModeSelect();
          } else if (e.key === "Enter") {
            playSound("menuSelect");
            selectedGameMode = gameModes[currentGameModeIndex];
            startGame();
          } else if (e.key === "Escape" || e.key.toLowerCase() === "q") {
            playSound("menuCancel");
            gameState = "menu";
            renderMainMenu();
          }
          return;
        } else if (gameState === "help") {
          if (e.key === "Escape" || e.key.toLowerCase() === "q") {
            playSound("menuCancel");
            gameState = "menu";
            renderMainMenu();
          }
          return;
        } else if (gameState === "settings") {
          if (e.key === "ArrowUp" || e.key.toLowerCase() === "w") {
            currentSettingsMenuIndex = (currentSettingsMenuIndex - 1 + 6) % 6;
            playSound("menuNavigate");
            renderSettingsMenu();
          } else if (e.key === "ArrowDown" || e.key.toLowerCase() === "s") {
            currentSettingsMenuIndex = (currentSettingsMenuIndex + 1) % 6;
            playSound("menuNavigate");
            renderSettingsMenu();
          } else if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a" || e.key === "ArrowRight" || e.key.toLowerCase() === "d") {
            playSound("menuChange");
            if (currentSettingsMenuIndex === 0) {
              const difficulties = ["Easy", "Normal", "Hard"];
              let index = difficulties.indexOf(difficultySetting);
              index = (e.key === "ArrowLeft" || e.key.toLowerCase() === "a")
                ? (index - 1 + difficulties.length) % difficulties.length
                : (index + 1) % difficulties.length;
              difficultySetting = difficulties[index];
              renderSettingsMenu();
              saveGameData();
            } else if (currentSettingsMenuIndex === 1) {
              colorMode = (colorMode === "colors") ? "monochrome" : "colors";
              renderSettingsMenu();
              saveGameData();
            } else if (currentSettingsMenuIndex === 2) {
              ghostPieceSetting = (ghostPieceSetting === "On") ? "Off" : "On";
              renderSettingsMenu();
              saveGameData();
            } else if (currentSettingsMenuIndex === 3) {
              soundSetting = (soundSetting === "On") ? "Off" : "On";
              renderSettingsMenu();
              saveGameData();
            } else if (currentSettingsMenuIndex === 4) {
              if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a") {
                soundVolume = Math.max(0, soundVolume - 0.1);
              } else {
                soundVolume = Math.min(1, soundVolume + 0.1);
              }
              renderSettingsMenu();
              saveGameData();
            }
          } else if (e.key === "Enter") {
            playSound("menuSelect");
            if (currentSettingsMenuIndex === 5) {
              gameState = "menu";
              renderMainMenu();
            }
          }
          return;
        } else if (gameState === "customization") {
          if (e.key === "ArrowUp" || e.key.toLowerCase() === "w") {
            let idx = storeCategories.indexOf(currentStoreCategory);
            idx = (idx - 1 + storeCategories.length) % storeCategories.length;
            currentStoreCategory = storeCategories[idx];
            currentStoreItemIndex = 0;
            playSound("menuNavigate");
            renderStore();
          } else if (e.key === "ArrowDown" || e.key.toLowerCase() === "s") {
            let idx = storeCategories.indexOf(currentStoreCategory);
            idx = (idx + 1) % storeCategories.length;
            currentStoreCategory = storeCategories[idx];
            currentStoreItemIndex = 0;
            playSound("menuNavigate");
            renderStore();
          } else if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a") {
            let items = storeItems[currentStoreCategory];
            currentStoreItemIndex = (currentStoreItemIndex - 1 + items.length) % items.length;
            playSound("menuChange");
            renderStore();
          } else if (e.key === "ArrowRight" || e.key.toLowerCase() === "d") {
            let items = storeItems[currentStoreCategory];
            currentStoreItemIndex = (currentStoreItemIndex + 1) % items.length;
            playSound("menuChange");
            renderStore();
          } else if (e.key === "Enter") {
            playSound("menuSelect");
            let currentItem = storeItems[currentStoreCategory][currentStoreItemIndex];
            if (!currentItem.unlocked) {
              if (coins >= currentItem.price) {
                coins -= currentItem.price;
                currentItem.unlocked = true;
                if (currentStoreCategory === "block") {
                  currentBlockAppearance = currentItem.appearance;
                } else if (currentStoreCategory === "border") {
                  currentBorderStyle = currentItem.topLeft
                    ? { topLeft: currentItem.topLeft, topRight: currentItem.topRight, bottomLeft: currentItem.bottomLeft, bottomRight: currentItem.bottomRight, horizontal: currentItem.horizontal, vertical: currentItem.vertical }
                    : { topLeft: currentItem.corner, topRight: currentItem.corner, bottomLeft: currentItem.corner, bottomRight: currentItem.corner, horizontal: currentItem.horizontal, vertical: currentItem.vertical };
                } else if (currentStoreCategory === "theme") {
                  currentTheme = { background: currentItem.background, color: currentItem.color };
                  document.body.style.backgroundColor = currentTheme.background;
                  document.body.style.color = currentTheme.color;
                } else if (currentStoreCategory === "tetromino") {
                  tetrominoColors = currentItem.colors;
                }
                saveGameData();
                showToast("Bought " + currentItem.name);
              } else {
                showToast("Not enough coins!");
              }
            } else {
              if (currentStoreCategory === "block") {
                currentBlockAppearance = currentItem.appearance;
              } else if (currentStoreCategory === "border") {
                currentBorderStyle = currentItem.topLeft
                  ? { topLeft: currentItem.topLeft, topRight: currentItem.topRight, bottomLeft: currentItem.bottomLeft, bottomRight: currentItem.bottomRight, horizontal: currentItem.horizontal, vertical: currentItem.vertical }
                  : { topLeft: currentItem.corner, topRight: currentItem.corner, bottomLeft: currentItem.corner, bottomRight: currentItem.corner, horizontal: currentItem.horizontal, vertical: currentItem.vertical };
              } else if (currentStoreCategory === "theme") {
                currentTheme = { background: currentItem.background, color: currentItem.color };
                document.body.style.backgroundColor = currentTheme.background;
                document.body.style.color = currentTheme.color;
              } else if (currentStoreCategory === "tetromino") {
                tetrominoColors = currentItem.colors;
              }
              saveGameData();
              showToast("Selected " + currentItem.name);
            }
            renderStore();
          } else if (e.key === "Escape" || e.key.toLowerCase() === "q") {
            playSound("menuCancel");
            gameState = "menu";
            renderMainMenu();
          }
          return;
        } else if (gameState === "gameover") {
          if (e.key === "Enter") {
            playSound("menuSelect");
            gameState = "menu";
            renderMainMenu();
          }
          return;
        } else if (gameState === "game") {
          if (e.key === "Escape" || e.key.toLowerCase() === "q") {
            paused = true;
            updateExitModal(true);
            return;
          }
          if (e.key.toLowerCase() === "p") {
            if (paused) {
              let pauseDuration = Date.now() - pauseStartTime;
              startTime += pauseDuration;
              if (selectedGameMode === "Time Attack") {
                lastTickTime += pauseDuration;
              }
              paused = false;
              pauseStartTime = null;
            } else {
              paused = true;
              pauseStartTime = Date.now();
            }
            playSound("menuSelect");
            updatePauseModal();
            renderGame();
          }
          if (paused) return;
          if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a") {
            if (validMove(fallingPiece.x - 1, fallingPiece.y, fallingPiece.rotation)) {
              fallingPiece.x--;
              playSound("move");
              renderGame();
            }
          } else if (e.key === "ArrowRight" || e.key.toLowerCase() === "d") {
            if (validMove(fallingPiece.x + 1, fallingPiece.y, fallingPiece.rotation)) {
              fallingPiece.x++;
              playSound("move");
              renderGame();
            }
          } else if (e.key === "ArrowDown" || e.key.toLowerCase() === "s") {
            if (validMove(fallingPiece.x, fallingPiece.y + 1, fallingPiece.rotation)) {
              fallingPiece.y++;
              playSound("move");
              renderGame();
            }
          } else if (e.key === "ArrowUp" || e.key.toLowerCase() === "w") {
            let newRotation = (fallingPiece.rotation + 1) % 4;
            if (tryRotate(newRotation)) playSound("rotate");
            renderGame();
          } else if (e.key.toLowerCase() === "z") {
            let newRotation = (fallingPiece.rotation + 3) % 4;
            if (tryRotate(newRotation)) playSound("rotate");
            renderGame();
          } else if (e.key === " ") {
            if (!spacebarHeld) {
              spacebarHeld = true;
              spacebarKeyDownTime = Date.now();
              spacebarHoldTimeout = setTimeout(() => {
                spacebarDropInterval = setInterval(() => {
                  if (validMove(fallingPiece.x, fallingPiece.y + 1, fallingPiece.rotation)) {
                    fallingPiece.y++;
                    playSound("drop");
                    renderGame();
                  } else {
                    clearInterval(spacebarDropInterval);
                    spacebarDropInterval = null;
                  }
                }, SPACEBAR_DROP_INTERVAL_TIME);
              }, SPACEBAR_HOLD_THRESHOLD);
            }
          }
        }
      });
      document.addEventListener("keyup", function(e) {
        if (e.key === " ") {
          spacebarHeld = false;
          if (spacebarHoldTimeout) {
            let elapsed = Date.now() - spacebarKeyDownTime;
            clearTimeout(spacebarHoldTimeout);
            spacebarHoldTimeout = null;
            if (elapsed < SPACEBAR_HOLD_THRESHOLD) {
              while (validMove(fallingPiece.x, fallingPiece.y + 1, fallingPiece.rotation)) {
                fallingPiece.y++;
              }
              playSound("drop");
              renderGame();
              gameTick();
            }
          }
          if (spacebarDropInterval) {
            clearInterval(spacebarDropInterval);
            spacebarDropInterval = null;
          }
        }
      });
      loadGameData();
      renderMainMenu();
    </script>
  </body>
</html>