<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Terminal Blocks</title>
    <style>
      html,
      body {
        overflow: hidden;
        margin: 0;
        padding: 0;
      }
      body {
        background-color: black;
        color: white;
        text-align: center;
        position: relative;
      }
      #game {
        width: 800px;
        height: 600px;
        margin: 20px auto;
        font-family: monospace;
        white-space: pre;
        font-size: 20px;
        line-height: 20px;
        background-color: black;
        overflow: hidden;
        border: none;
      }
      #pauseModal,
      #exitModal {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0,0,0,0.9);
        border: 2px solid white;
        padding: 20px;
        font-family: monospace;
        white-space: pre;
        font-size: 24px;
        color: white;
        display: none;
        z-index: 10;
      }
    </style>
  </head>
  <body>
    <div id="game"></div>
    <div id="pauseModal">PAUSED<br><br>Press P to resume</div>
    <div id="exitModal">Exit Game?<br><br>Press Y to confirm, N to resume</div>
    <script>
      let gameState = "menu";
      const mainMenuOptions = ["Play", "Instructions", "Settings", "Customization"];
      let currentMainMenuIndex = 0;
      const settingsMenuOptions = ["Difficulty", "Color Mode", "Back"];
      let currentSettingsMenuIndex = 0;
      const gameModes = ["Normal", "Time Attack", "Chaos Blitz", "Hardcore"];
      let currentGameModeIndex = 0;
      let selectedGameMode = "Normal";
      const boardWidth = 10;
      const boardHeight = 20;
      let board = [];
      let fallingPiece = null;
      let gameOver = false;
      let animating = false;
      let animatingRows = [];
      let flashState = false;
      let flashInterval = null;
      let level = 0;
      let linesCleared = 0;
      let score = 0;
      let paused = false;
      let combo = 0;
      let specialMessage = "";
      let difficultySetting = "Normal";
      let colorMode = "colors";
      const difficultyConfig = {
        Easy: { initialSpeed: 700, acceleration: 0.98 },
        Normal: { initialSpeed: 500, acceleration: 0.95 },
        Hard: { initialSpeed: 300, acceleration: 0.90 }
      };
      let coins = 0;
      let currentBlockAppearance = "[]";
      let currentBorderStyle = { 
        topLeft: "┌", 
        topRight: "┐", 
        bottomLeft: "└", 
        bottomRight: "┘", 
        horizontal: "─", 
        vertical: "│" 
      };
      let currentTheme = { background: "black", color: "white" };
      const storeItems = {
        block: [
          { name: "Standard", appearance: "[]", price: 0, unlocked: true },
          { name: "Neon", appearance: "||", price: 0, unlocked: true },
          { name: "Pixel", appearance: "##", price: 0, unlocked: true },
          { name: "Checker", appearance: "█░", price: 0, unlocked: true },
          { name: "Hashes", appearance: "##", price: 500, unlocked: false },
          { name: "Arrows", appearance: "<>", price: 1000, unlocked: false },
          { name: "Smileys", appearance: ":)", price: 2000, unlocked: false }
        ],
        border: [
          { name: "Standard", corner: "+", horizontal: "-", vertical: "|" , price: 0, unlocked: true },
          { name: "Double", corner: "╔", horizontal: "═", vertical: "║", price: 0, unlocked: true },
          { name: "Dashed", corner: "·", horizontal: "–", vertical: "│", price: 0, unlocked: true },
          { name: "Sharp", corner: "#", horizontal: "=", vertical: "!" , price: 750, unlocked: false },
          { name: "Star", corner: "*", horizontal: "*", vertical: "*" , price: 1500, unlocked: false }
        ],
        theme: [
          { name: "Default", background: "black", color: "white", price: 0, unlocked: true },
          { name: "Solarized", background: "#002b36", color: "#839496", price: 0, unlocked: true },
          { name: "Monokai", background: "#272822", color: "#f8f8f2", price: 0, unlocked: true },
          { name: "Red Alert", background: "black", color: "red", price: 500, unlocked: false },
          { name: "Green Matrix", background: "black", color: "lime", price: 750, unlocked: false },
          { name: "Blue Ocean", background: "navy", color: "cyan", price: 1000, unlocked: false }
        ]
      };
      const storeCategories = ["block", "border", "theme"];
      let currentStoreCategory = "block";
      let currentStoreItemIndex = 0;
      const tetrominoes = [
        { name: "I", shape: [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 2, y: 0 }, { x: 3, y: 0 }] },
        { name: "J", shape: [{ x: 0, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1 }] },
        { name: "L", shape: [{ x: 2, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1 }] },
        { name: "O", shape: [{ x: 1, y: 0 }, { x: 2, y: 0 }, { x: 1, y: 1 }, { x: 2, y: 1 }] },
        { name: "S", shape: [{ x: 1, y: 0 }, { x: 2, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }] },
        { name: "T", shape: [{ x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1 }] },
        { name: "Z", shape: [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 1, y: 1 }, { x: 2, y: 1 }] }
      ];
      const blockColors = {
        I: "cyan",
        J: "blue",
        L: "orange",
        O: "yellow",
        S: "lime",
        T: "magenta",
        Z: "red"
      };
      let highScore = 0;
      function loadGameData(){ let data = localStorage.getItem("terminalBlocksData"); if(data){ let obj = JSON.parse(data); highScore = obj.highScore !== undefined ? obj.highScore : 0; difficultySetting = obj.difficultySetting || difficultySetting; colorMode = obj.colorMode || colorMode; coins = obj.coins !== undefined ? obj.coins : coins; currentBlockAppearance = obj.currentBlockAppearance || currentBlockAppearance; currentBorderStyle = obj.currentBorderStyle || currentBorderStyle; currentTheme = obj.currentTheme || currentTheme; if(obj.storeItems){ for(let cat in storeItems){ if(obj.storeItems[cat]){ storeItems[cat].forEach((item, index)=>{ storeItems[cat][index].unlocked = item.unlocked; }); } } } } }
      function saveGameData(){ let data = { highScore: highScore, difficultySetting: difficultySetting, colorMode: colorMode, coins: coins, currentBlockAppearance: currentBlockAppearance, currentBorderStyle: currentBorderStyle, currentTheme: currentTheme, storeItems: storeItems }; localStorage.setItem("terminalBlocksData", JSON.stringify(data)); }
      function rotateOffset(offset, rotation) {
        let x = offset.x, y = offset.y;
        for (let i = 0; i < rotation; i++) {
          let temp = x;
          x = -y;
          y = temp;
        }
        return { x, y };
      }
      function getPieceCells(piece) {
        return piece.shape.map(cell => {
          let r = rotateOffset(cell, piece.rotation);
          return { x: piece.x + r.x, y: piece.y + r.y };
        });
      }
      function validMove(newX, newY, newRotation) {
        for (let cell of fallingPiece.shape) {
          let r = rotateOffset(cell, newRotation);
          let x = newX + r.x;
          let y = newY + r.y;
          if (x < 0 || x >= boardWidth || y >= boardHeight) {
            if (y >= 0) return false;
          }
          if (y >= 0 && board[y][x] !== 0) return false;
        }
        return true;
      }
      function lockPiece(piece) {
        let cells = getPieceCells(piece);
        for (let cell of cells) {
          if (cell.y >= 0 && cell.y < boardHeight && cell.x >= 0 && cell.x < boardWidth) {
            board[cell.y][cell.x] = fallingPiece.name;
          }
        }
      }
      function getFullLines() {
        let fullLines = [];
        for (let y = 0; y < boardHeight; y++) {
          let full = true;
          for (let x = 0; x < boardWidth; x++) {
            if (board[y][x] === 0) {
              full = false;
              break;
            }
          }
          if (full) fullLines.push(y);
        }
        return fullLines;
      }
      function clearFullLines() {
        let newBoard = board.filter(row => row.some(cell => cell === 0));
        while (newBoard.length < boardHeight) {
          newBoard.unshift(new Array(boardWidth).fill(0));
        }
        board = newBoard;
      }
      function animateClearLines(callback) {
        animatingRows = getFullLines();
        let flashes = 0;
        flashInterval = setInterval(() => {
          flashState = !flashState;
          flashes++;
          renderGame();
          if (flashes >= 6) {
            clearInterval(flashInterval);
            animatingRows = [];
            callback();
          }
        }, 150);
      }
      function animateTetris(callback) {
        let flashes = 0;
        flashInterval = setInterval(() => {
          flashes++;
          specialMessage = flashes % 2 === 0 ? "Max Line!" : "";
          renderGame();
          if (flashes >= 6) {
            clearInterval(flashInterval);
            specialMessage = "";
            callback();
          }
        }, 150);
      }
      function animateLevelUp(callback) {
        let flashes = 0;
        flashInterval = setInterval(() => {
          flashes++;
          specialMessage = flashes % 2 === 0 ? "LEVEL UP!" : "";
          renderGame();
          if (flashes >= 6) {
            clearInterval(flashInterval);
            specialMessage = "";
            callback();
          }
        }, 150);
      }
      function computeGhostCells() {
        if (!fallingPiece) return [];
        let ghost = { x: fallingPiece.x, y: fallingPiece.y, shape: fallingPiece.shape, rotation: fallingPiece.rotation };
        while (validMove(ghost.x, ghost.y + 1, ghost.rotation)) {
          ghost.y++;
        }
        return getPieceCells(ghost);
      }
      let timeAttackRemaining = 60000;
      let lastTickTime = 0;
      let startTime = 0;
      function getDropSpeed() {
        let effectiveLevel = level + Math.floor((Date.now() - startTime) / 30000);
        if (selectedGameMode === "Hardcore") {
          return Math.max(50, Math.floor(100 * Math.pow(0.7, effectiveLevel)));
        } else {
          const config = difficultyConfig[difficultySetting];
          return Math.max(100, Math.floor(config.initialSpeed * Math.pow(config.acceleration, effectiveLevel)));
        }
      }
      function renderGame() {
        let header = "Level: " + level + "  Lines: " + linesCleared + "  Score: " + score;
        if (combo > 1) header += "  Combo: x" + combo;
        if (selectedGameMode === "Time Attack") {
          let timeLeftSec = Math.ceil(timeAttackRemaining / 1000);
          header += "  Time: " + timeLeftSec + "s";
        }
        header += "\n";
        const bs = currentBorderStyle;
        let topBorder = bs.topLeft + bs.horizontal.repeat(boardWidth * 2) + bs.topRight + "\n";
        let bottomBorder = bs.bottomLeft + bs.horizontal.repeat(boardWidth * 2) + bs.bottomRight + "\n";
        let output = header + topBorder;
        let fallingCells = getPieceCells(fallingPiece);
        let ghostCells = computeGhostCells();
        for (let y = 0; y < boardHeight; y++) {
          let row = bs.vertical;
          if (animatingRows.indexOf(y) !== -1) {
            let pattern = flashState ? "##" : "~~";
            row += pattern.repeat(boardWidth);
          } else {
            if (y === Math.floor(boardHeight / 2) && specialMessage) {
              let msg = specialMessage;
              let total = boardWidth * 2;
              let pad = Math.floor((total - msg.length) / 2);
              let spaces = " ".repeat(pad);
              row += spaces + msg + spaces;
              if (row.length < total + 1) row += " ";
            } else {
              for (let x = 0; x < boardWidth; x++) {
                let cellDraw = "  ";
                let inFalling = fallingCells.some(c => c.x === x && c.y === y);
                let inGhost = ghostCells.some(c => c.x === x && c.y === y);
                if (inFalling) {
                  if (colorMode === "colors") {
                    cellDraw = '<span style="color:' + blockColors[fallingPiece.name] + ';">' + currentBlockAppearance + '</span>';
                  } else {
                    cellDraw = currentBlockAppearance;
                  }
                } else if (inGhost && board[y][x] === 0) {
                  if (colorMode === "colors") {
                    cellDraw = '<span style="color:gray;">..</span>';
                  } else {
                    cellDraw = "..";
                  }
                } else if (board[y][x] !== 0) {
                  if (colorMode === "colors") {
                    cellDraw = '<span style="color:' + blockColors[board[y][x]] + ';">' + currentBlockAppearance + '</span>';
                  } else {
                    cellDraw = currentBlockAppearance;
                  }
                }
                row += cellDraw;
              }
            }
          }
          row += bs.vertical + "\n";
          output += row;
        }
        output += bottomBorder;
        document.getElementById("game").innerHTML = output;
      }
      function renderMainMenu() {
        let logo = `
 ▄▄▄▄    ██▓     ▒█████   ▄████▄   ██ ▄█▀
▓█████▄ ▓██▒    ▒██▒  ██▒▒██▀ ▀█   ██▄█▒ 
▒██▒ ▄██▒██░    ▒██░  ██▒▒▓█    ▄ ▓███▄░ 
▒██░█▀  ▒██░    ▒██   ██░▒▓▓▄ ▄██▒▓██ █▄ 
░▓█  ▀█▓░██████▒░ ████▓▒░▒ ▓███▀ ░▒██▒ █▄
░▒▓███▀▒░ ▒░▓  ░░ ▒░▒░▒░ ░ ░▒ ▒  ░▒ ▒▒ ▓▒
▒░▒   ░ ░ ░ ▒  ░  ░ ▒ ▒░   ░  ▒   ░ ░▒ ▒░
 ░    ░   ░ ░   ░ ░░ ░  ░        ░ ░░ ░ 
 ░          ░  ░    ░ ░  ░ ░      ░  ░   `;
        let header = logo + "\n\nTerminal Blocks\n\nHigh Score: " + highScore + "\n\n";
        mainMenuOptions.forEach((option, i) => {
          header += (i === currentMainMenuIndex ? "> " : "  ") + option + "\n";
        });
        header += "\nUse W/S to navigate and Enter to select.";
        document.getElementById("game").innerHTML = header;
      }
      function renderModeSelect() {
        let output = "Select Game Mode\n\n";
        let maxLen = Math.max(...gameModes.map(mode => mode.length));
        let boxWidth = maxLen + 2;
        gameModes.forEach((mode, i) => {
          let top = "┌" + "─".repeat(boxWidth) + "┐";
          let middle = "│" + mode.padEnd(boxWidth, " ") + "│";
          let bottom = "└" + "─".repeat(boxWidth) + "┘";
          let marker = i === currentGameModeIndex ? ">" : " ";
          output += marker + " " + top + "\n" + marker + " " + middle + "\n" + marker + " " + bottom + "\n\n";
        });
        output += "Use W/S to navigate and Enter to select.\nPress Esc/Q to return to Main Menu.";
        document.getElementById("game").innerHTML = output;
      }
      function renderSettingsMenu() {
        let items = [
          "Difficulty: " + difficultySetting,
          "Color Mode: " + (colorMode === "colors" ? "Colors" : "Monochrome"),
          "Back"
        ];
        let width = 32;
        let border = { topLeft: "╔", topRight: "╗", bottomLeft: "╚", bottomRight: "╝", horizontal: "═", vertical: "║" };
        let output = border.topLeft + border.horizontal.repeat(width - 2) + border.topRight + "\n";
        let title = " SETTINGS ";
        let padLeft = Math.floor((width - 2 - title.length) / 2);
        let padRight = width - 2 - title.length - padLeft;
        output += border.vertical + " ".repeat(padLeft) + title + " ".repeat(padRight) + border.vertical + "\n";
        output += "├" + "─".repeat(width - 2) + "┤\n";
        for (let i = 0; i < items.length; i++) {
          let padded = items[i].padEnd(width - 4, " ");
          output += i === currentSettingsMenuIndex ? border.vertical + " > " + padded + border.vertical + "\n" : border.vertical + "   " + padded + border.vertical + "\n";
        }
        output += border.bottomLeft + border.horizontal.repeat(width - 2) + border.bottomRight + "\n";
        output += "\nUse W/S to navigate, A/D to change values, and Enter to select.\nPress Esc/Q to return to Main Menu.";
        document.getElementById("game").innerHTML = output;
      }
      function renderStore() {
        let output = "Customization Store\n";
        output += "Coins: " + coins + "\n\n";
        const catNames = { block: "Block Appearance", border: "Border Style", theme: "Theme" };
        let currentCatIndex = storeCategories.indexOf(currentStoreCategory);
        output += "Categories: ";
        storeCategories.forEach((cat, i) => {
          output += (i === currentCatIndex ? "[" + catNames[cat] + "]" : " " + catNames[cat] + " ") + "   ";
        });
        output += "\n\n";
        let currentItem = storeItems[currentStoreCategory][currentStoreItemIndex];
        output += "Item: " + currentItem.name + "\n";
        if (currentStoreCategory === "block") {
          output += "Appearance: " + currentItem.appearance + "\n";
        } else if (currentStoreCategory === "border") {
          output += "Preview: " + currentItem.corner + currentItem.horizontal + "\n";
        } else if (currentStoreCategory === "theme") {
          output += "Background: " + currentItem.background + "\n";
          output += "Text Color: " + currentItem.color + "\n";
        }
        output += "Price: " + currentItem.price + "\n";
        output += "Status: " + (currentItem.unlocked ? "Owned" : "Not Owned") + "\n\n";
        output += "Use W/S to switch category,\nA/D to change item.\nPress Enter to purchase/select, or Esc/Q to return to Main Menu.";
        document.getElementById("game").innerHTML = output;
      }
      function renderHelpMenu() {
        let output = "Instructions\n\n";
        output += "Movement: Use W/A/S/D or Arrow keys to move pieces.\n";
        output += "Rotation: Press W or Up to rotate, Z to counter-rotate.\n";
        output += "Drop: Press Spacebar for instant drop.\n";
        output += "Pause: Press P to pause.\n";
        output += "Exit: Press Esc/Q to open the exit modal.\n";
        output += "Menu Navigation: Use W/S to navigate and Enter to select.\n";
        output += "\nPress Esc/Q to return to the Main Menu.";
        document.getElementById("game").innerHTML = output;
      }
      function renderGameOver() {
        let art = `
  ▄████  ▄▄▄       ███▄ ▄███▓▓█████    
 ██▒ ▀█▒▒████▄    ▓██▒▀█▀ ██▒▓█   ▀    
▒██░▄▄▄░▒██  ▀█▄  ▓██    ▓██░▒███      
░▓█  ██▓░██▄▄▄▄██ ▒██    ▒██ ▒▓█  ▄    
░▒▓███▀▒ ▓█   ▓██▒▒██▒   ░██▒░▒████▒   
 ░▒   ▒  ▒▒   ▓▒█░░ ▒░   ░  ░░░ ▒░ ░   
  ░   ░   ▒   ▒▒ ░░  ░      ░ ░ ░  ░   
░ ░   ░   ░   ▒   ░      ░      ░      
      ░       ░  ░       ░      ░  ░   
                                       
 ▒█████   ██▒   █▓▓█████  ██▀███       
▒██▒  ██▒▓██░   █▒▓█   ▀ ▓██ ▒ ██▒     
▒██░  ██▒ ▓██  █▒░▒███   ▓██ ░▄█ ▒     
▒██   ██░  ▒██ █░░▒▓█  ▄ ▒██▀▀█▄       
░ ████▓▒░   ▒▀█░  ░▒████▒░██▓ ▒██▒     
░ ▒░▒░▒░    ░ ▐░  ░░ ▒░ ░░ ▒▓ ░▒▓░     
  ░ ▒ ▒░    ░ ░░   ░ ░  ░  ░▒ ░ ▒░     
░ ░ ░ ▒       ░░     ░     ░░   ░      
    ░ ░        ░     ░  ░   ░          
              ░                         
`;
        let output = art + "\n";
        output += "Score: " + score + "\n";
        output += "Coins Earned: " + Math.floor(score / 50) + "\n";
        output += "\nPress Enter to return to the Main Menu.";
        document.getElementById("game").innerHTML = output;
      }
      function tryRotate(newRotation) {
        if (fallingPiece.name === "O") return true;
        if (validMove(fallingPiece.x, fallingPiece.y, newRotation)) {
          fallingPiece.rotation = newRotation;
          return true;
        }
        if (validMove(fallingPiece.x - 1, fallingPiece.y, newRotation)) {
          fallingPiece.x--;
          fallingPiece.rotation = newRotation;
          return true;
        }
        if (validMove(fallingPiece.x + 1, fallingPiece.y, newRotation)) {
          fallingPiece.x++;
          fallingPiece.rotation = newRotation;
          return true;
        }
        return false;
      }
      let nextPiece;
      function spawnPiece() {
        const index = Math.floor(Math.random() * tetrominoes.length);
        const tetromino = tetrominoes[index];
        return { x: Math.floor(boardWidth / 2) - 2, y: 0, shape: tetromino.shape, rotation: 0, name: tetromino.name };
      }
      function initBoard() {
        board = [];
        for (let y = 0; y < boardHeight; y++) {
          let row = [];
          for (let x = 0; x < boardWidth; x++) {
            row.push(0);
          }
          board.push(row);
        }
      }
      function gameTick() {
        if (gameOver || animating || paused) return;
        if (selectedGameMode === "Chaos Blitz" && Math.random() < 0.05) {
          let oldShape = fallingPiece.shape;
          let oldName = fallingPiece.name;
          let newTetromino = tetrominoes[Math.floor(Math.random() * tetrominoes.length)];
          fallingPiece.shape = newTetromino.shape;
          fallingPiece.name = newTetromino.name;
          if (!validMove(fallingPiece.x, fallingPiece.y, fallingPiece.rotation)) {
            fallingPiece.shape = oldShape;
            fallingPiece.name = oldName;
          } else {
            specialMessage = "CHAOS!";
            setTimeout(() => { specialMessage = ""; renderGame(); }, 500);
          }
        }
        if (selectedGameMode === "Time Attack") {
          let now = Date.now();
          let dt = now - lastTickTime;
          timeAttackRemaining -= dt;
          lastTickTime = now;
          if (timeAttackRemaining <= 0) gameOver = true;
        }
        if (validMove(fallingPiece.x, fallingPiece.y + 1, fallingPiece.rotation)) {
          fallingPiece.y++;
          renderGame();
        } else {
          lockPiece(fallingPiece);
          let fullLines = getFullLines();
          if (fullLines.length > 0) {
            if (selectedGameMode === "Time Attack") {
              let bonus = 0;
              if (fullLines.length === 1) bonus = 2000;
              else if (fullLines.length === 2) bonus = 3000;
              else if (fullLines.length === 3) bonus = 4000;
              else if (fullLines.length === 4) bonus = 6000;
              timeAttackRemaining += bonus;
            }
            combo++;
            if (fullLines.length === 4) {
              animating = true;
              animateTetris(() => {
                clearFullLines();
                linesCleared += fullLines.length;
                let basePoints = 1200 * (level + 1);
                let pointsAwarded = basePoints * (combo > 1 ? combo : 1);
                score += pointsAwarded;
                let newLevel = Math.floor(linesCleared / 10);
                if (newLevel > level) {
                  animateLevelUp(() => {
                    level = newLevel;
                    animating = false;
                    fallingPiece = spawnPiece();
                    if (!validMove(fallingPiece.x, fallingPiece.y, fallingPiece.rotation)) gameOver = true;
                    renderGame();
                  });
                } else {
                  level = newLevel;
                  animating = false;
                  fallingPiece = spawnPiece();
                  if (!validMove(fallingPiece.x, fallingPiece.y, fallingPiece.rotation)) gameOver = true;
                  renderGame();
                }
              });
            } else {
              animating = true;
              animateClearLines(() => {
                clearFullLines();
                linesCleared += fullLines.length;
                let basePoints = fullLines.length === 1 ? 40 * (level + 1) : fullLines.length === 2 ? 100 * (level + 1) : 300 * (level + 1);
                let pointsAwarded = basePoints * (combo > 1 ? combo : 1);
                score += pointsAwarded;
                let newLevel = Math.floor(linesCleared / 10);
                if (newLevel > level) {
                  animateLevelUp(() => {
                    level = newLevel;
                    animating = false;
                    fallingPiece = spawnPiece();
                    if (!validMove(fallingPiece.x, fallingPiece.y, fallingPiece.rotation)) gameOver = true;
                    renderGame();
                  });
                } else {
                  level = newLevel;
                  animating = false;
                  fallingPiece = spawnPiece();
                  if (!validMove(fallingPiece.x, fallingPiece.y, fallingPiece.rotation)) gameOver = true;
                  renderGame();
                }
              });
            }
          } else {
            combo = 0;
            fallingPiece = spawnPiece();
            if (!validMove(fallingPiece.x, fallingPiece.y, fallingPiece.rotation)) gameOver = true;
          }
          renderGame();
        }
      }
      function gameLoop() {
        if (gameState !== "game") return;
        if (paused) {
          setTimeout(gameLoop, 100);
          return;
        }
        gameTick();
        if (!gameOver) {
          setTimeout(gameLoop, getDropSpeed());
        } else {
          coins += Math.floor(score / 50);
          if(score > highScore) highScore = score;
          saveGameData();
          gameState = "gameover";
          renderGameOver();
        }
      }
      function startGame() {
        gameState = "game";
        gameOver = false;
        level = 0;
        linesCleared = 0;
        score = 0;
        combo = 0;
        paused = false;
        updatePauseModal();
        initBoard();
        startTime = Date.now();
        if (selectedGameMode === "Time Attack") {
          timeAttackRemaining = 60000;
          lastTickTime = Date.now();
        }
        nextPiece = spawnPiece();
        fallingPiece = nextPiece;
        nextPiece = spawnPiece();
        gameLoop();
      }
      function updatePauseModal() {
        let modal = document.getElementById("pauseModal");
        modal.style.display = paused ? "block" : "none";
      }
      function updateExitModal(show) {
        let modal = document.getElementById("exitModal");
        modal.style.display = show ? "block" : "none";
      }
      document.addEventListener("keydown", function (e) {
        if (gameState === "game" && document.getElementById("exitModal").style.display === "block") {
          if (e.key.toLowerCase() === "y") {
            paused = false;
            updateExitModal(false);
            gameState = "menu";
            renderMainMenu();
          } else if (e.key.toLowerCase() === "n") {
            paused = false;
            updateExitModal(false);
            renderGame();
          }
          return;
        }
        if (gameState === "menu") {
          if (e.key === "ArrowUp" || e.key.toLowerCase() === "w") {
            currentMainMenuIndex = (currentMainMenuIndex - 1 + mainMenuOptions.length) % mainMenuOptions.length;
            renderMainMenu();
          } else if (e.key === "ArrowDown" || e.key.toLowerCase() === "s") {
            currentMainMenuIndex = (currentMainMenuIndex + 1) % mainMenuOptions.length;
            renderMainMenu();
          } else if (e.key === "Enter") {
            const option = mainMenuOptions[currentMainMenuIndex];
            if (option === "Play") {
              gameState = "modeSelect";
              currentGameModeIndex = gameModes.indexOf(selectedGameMode);
              renderModeSelect();
            } else if (option === "Instructions") {
              gameState = "help";
              renderHelpMenu();
            } else if (option === "Settings") {
              gameState = "settings";
              currentSettingsMenuIndex = 0;
              renderSettingsMenu();
            } else if (option === "Customization") {
              gameState = "customization";
              currentStoreCategory = "block";
              currentStoreItemIndex = 0;
              renderStore();
            }
          }
          return;
        } else if (gameState === "modeSelect") {
          if (e.key === "ArrowUp" || e.key.toLowerCase() === "w") {
            currentGameModeIndex = (currentGameModeIndex - 1 + gameModes.length) % gameModes.length;
            renderModeSelect();
          } else if (e.key === "ArrowDown" || e.key.toLowerCase() === "s") {
            currentGameModeIndex = (currentGameModeIndex + 1) % gameModes.length;
            renderModeSelect();
          } else if (e.key === "Enter") {
            selectedGameMode = gameModes[currentGameModeIndex];
            startGame();
          } else if (e.key === "Escape" || e.key.toLowerCase() === "q") {
            gameState = "menu";
            renderMainMenu();
          }
          return;
        } else if (gameState === "help") {
          if (e.key === "Escape" || e.key.toLowerCase() === "q") {
            gameState = "menu";
            renderMainMenu();
          }
          return;
        } else if (gameState === "settings") {
          if (e.key === "ArrowUp" || e.key.toLowerCase() === "w") {
            currentSettingsMenuIndex = (currentSettingsMenuIndex - 1 + settingsMenuOptions.length) % settingsMenuOptions.length;
            renderSettingsMenu();
          } else if (e.key === "ArrowDown" || e.key.toLowerCase() === "s") {
            currentSettingsMenuIndex = (currentSettingsMenuIndex + 1) % settingsMenuOptions.length;
            renderSettingsMenu();
          } else if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a" || e.key === "ArrowRight" || e.key.toLowerCase() === "d") {
            if (currentSettingsMenuIndex === 0) {
              const difficulties = ["Easy", "Normal", "Hard"];
              let index = difficulties.indexOf(difficultySetting);
              index = (e.key === "ArrowLeft" || e.key.toLowerCase() === "a")
                ? (index - 1 + difficulties.length) % difficulties.length
                : (index + 1) % difficulties.length;
              difficultySetting = difficulties[index];
              renderSettingsMenu();
              saveGameData();
            } else if (currentSettingsMenuIndex === 1) {
              colorMode = (colorMode === "colors") ? "monochrome" : "colors";
              renderSettingsMenu();
              saveGameData();
            }
          } else if (e.key === "Enter") {
            if (currentSettingsMenuIndex === 2) {
              gameState = "menu";
              renderMainMenu();
            }
          }
          return;
        } else if (gameState === "customization") {
          if (e.key === "ArrowUp" || e.key.toLowerCase() === "w") {
            let idx = storeCategories.indexOf(currentStoreCategory);
            idx = (idx - 1 + storeCategories.length) % storeCategories.length;
            currentStoreCategory = storeCategories[idx];
            currentStoreItemIndex = 0;
            renderStore();
          } else if (e.key === "ArrowDown" || e.key.toLowerCase() === "s") {
            let idx = storeCategories.indexOf(currentStoreCategory);
            idx = (idx + 1) % storeCategories.length;
            currentStoreCategory = storeCategories[idx];
            currentStoreItemIndex = 0;
            renderStore();
          } else if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a") {
            let items = storeItems[currentStoreCategory];
            currentStoreItemIndex = (currentStoreItemIndex - 1 + items.length) % items.length;
            renderStore();
          } else if (e.key === "ArrowRight" || e.key.toLowerCase() === "d") {
            let items = storeItems[currentStoreCategory];
            currentStoreItemIndex = (currentStoreItemIndex + 1) % items.length;
            renderStore();
          } else if (e.key === "Enter") {
            let currentItem = storeItems[currentStoreCategory][currentStoreItemIndex];
            if (!currentItem.unlocked) {
              if (coins >= currentItem.price) {
                coins -= currentItem.price;
                currentItem.unlocked = true;
                if (currentStoreCategory === "block") {
                  currentBlockAppearance = currentItem.appearance;
                } else if (currentStoreCategory === "border") {
                  currentBorderStyle = { 
                    topLeft: currentItem.corner, 
                    topRight: currentItem.corner, 
                    bottomLeft: currentItem.corner, 
                    bottomRight: currentItem.corner, 
                    horizontal: currentItem.horizontal, 
                    vertical: currentItem.vertical 
                  };
                } else if (currentStoreCategory === "theme") {
                  currentTheme = { background: currentItem.background, color: currentItem.color };
                  document.body.style.backgroundColor = currentTheme.background;
                  document.body.style.color = currentTheme.color;
                }
                saveGameData();
              } else {
                alert("Not enough coins!");
              }
            } else {
              if (currentStoreCategory === "block") {
                currentBlockAppearance = currentItem.appearance;
              } else if (currentStoreCategory === "border") {
                currentBorderStyle = { 
                  topLeft: currentItem.corner, 
                  topRight: currentItem.corner, 
                  bottomLeft: currentItem.corner, 
                  bottomRight: currentItem.corner, 
                  horizontal: currentItem.horizontal, 
                  vertical: currentItem.vertical 
                };
              } else if (currentStoreCategory === "theme") {
                currentTheme = { background: currentItem.background, color: currentItem.color };
                document.body.style.backgroundColor = currentTheme.background;
                document.body.style.color = currentTheme.color;
              }
              saveGameData();
            }
            renderStore();
          } else if (e.key === "Escape" || e.key.toLowerCase() === "q") {
            gameState = "menu";
            renderMainMenu();
          }
          return;
        } else if (gameState === "gameover") {
          if (e.key === "Enter") {
            gameState = "menu";
            renderMainMenu();
          }
          return;
        } else if (gameState === "game") {
          if (e.key === "Escape" || e.key.toLowerCase() === "q") {
            paused = true;
            updateExitModal(true);
            return;
          }
          if (e.key.toLowerCase() === "p") {
            paused = !paused;
            updatePauseModal();
            renderGame();
          }
          if (paused) return;
          if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a") {
            if (validMove(fallingPiece.x - 1, fallingPiece.y, fallingPiece.rotation)) {
              fallingPiece.x--;
              renderGame();
            }
          } else if (e.key === "ArrowRight" || e.key.toLowerCase() === "d") {
            if (validMove(fallingPiece.x + 1, fallingPiece.y, fallingPiece.rotation)) {
              fallingPiece.x++;
              renderGame();
            }
          } else if (e.key === "ArrowDown" || e.key.toLowerCase() === "s") {
            if (validMove(fallingPiece.x, fallingPiece.y + 1, fallingPiece.rotation)) {
              fallingPiece.y++;
              renderGame();
            }
          } else if (e.key === "ArrowUp" || e.key.toLowerCase() === "w") {
            let newRotation = (fallingPiece.rotation + 1) % 4;
            tryRotate(newRotation);
            renderGame();
          } else if (e.key.toLowerCase() === "z") {
            let newRotation = (fallingPiece.rotation + 3) % 4;
            tryRotate(newRotation);
            renderGame();
          } else if (e.key === " ") {
            while (validMove(fallingPiece.x, fallingPiece.y + 1, fallingPiece.rotation)) {
              fallingPiece.y++;
            }
            renderGame();
            gameTick();
          }
        }
      });
      loadGameData();
      renderMainMenu();
    </script>
  </body>
</html>